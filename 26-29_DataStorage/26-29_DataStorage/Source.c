#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//int main()
//{
//	//①内置的类型：int、float、double、char等等
//	int a = 4;//4byte
//	float b = 4;//4byte
//	//但是二者在内存中存储形式不同
//
//	short c = 0;
//	short int d = 0;//这里的int可写可不写
//
//
//	//②构造类型：数组 、 结构体、枚举、联合（union）
//	//③指针类型
//	//④空类型 void――用于函数返回值类型、函数参数、指针类型。
//
//	return 0;
//}

//void test()//没有参数列表
//void test(void)//也能被传参调用，但是会报警告
//{
//	printf("hehe\n");
//}
//
//int main()
//{
//	test(100);//即使传参也是能调用test的，这是C语言留下来的比较模糊的地方
//	return 0;
//}

//int main()
//{
//	int a = 20;
//	//00000000 00000000 00000000 00010100 - 原码
//	//00000000 00000000 00000000 00010100 - 反码 
//	//00000000 00000000 00000000 00010100 - 补码: 00 00 00 14
//	int b = -10;
//	//10000000 00000000 00000000 00001010 - 原码
//	//11111111 11111111 11111111 11110101 - 反码
//	//11111111 11111111 11111111 11110110 - 补码	： ff ff ff f6
//
//	return 0;
//}

//大端、小端
//大端存储模式：数据的低位保存在内存的高地址中，数据的高位则保存在内存的低地址
//小端存储模式：     低位          低地址   ，     高位           高地址――当前机器上是这种模式

//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//}

//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	//返回1：小端、返回0：大端
//	return *p;
//}
//
//int main()
//{
//	//返回1 - 小端 、 0 - 大端
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	//11111111
//	//11111111 11111111 11111111 11111111  -> -1
//	signed char b = -1;
//	//11111111 
//	//11111111 11111111 11111111 11111111  -> -1
//	unsigned char c = -1;
//	//11111111
//	//00000000 00000000 00000000 11111111 -> 255
//	printf("a = %d,b = %d, c = %d\n", a, b, c);
//	//打印的时候是%d，要进行【整形提升】
//	return 0;
//}

//int main()
//{
//	//char a = -128; 
//	char a = 128; //结果也是一样的，128存到a中溢出 实际上存的是-128
//	//10000000 00000000 00000000 10000000 - -128原码
//	//11111111 11111111 11111111 01111111 - -128反码
//	//11111111 11111111 11111111 10000000 - -128补码
//	//10000000 - a
//
//	
//	//%u 是打印十进制无符号数 
//	//char 整形提升
//	printf("%d\n", a);
//	printf("%u\n",a); //2^32 - 127
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	//10000000 00000000 00000000 00010100
//	//11111111 11111111 11111111 11101011
//	//11111111 11111111 11111111 11101100 - 补码
//	unsigned int j = 10;
//	//00000000 00000000 00000000 00001010
//	//补码相加
//	//11111111 11111111 11111111 11110110
//	//10000000 00000000 00000000 00001010 -> -10
//	printf("%d\n", i + j);
//	//按照补码形式进行运算，最后格式化为有符号数
//
//	return 0;
//}


//#include<windows.h>
//int main()
//{
//	unsigned int i;
//	//0000 1001 - 无符号9
//	for (i = 9; i >= 0; i--)//死循环原因：i永远为正
//	{
//		printf("%u\n", i);//以十进制无符号数打印
//		Sleep(100);
//	}
//	return 0;
//}


//#include<string.h>
//int main()
//{
//	char a[1000]; //char : -128 ~ 127
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//会溢出
//	}
//	//a中放的元素：-1 -2 -3 ... -128 (127) 126 125 ... 1 0 (0就是‘\0’)
//	//
//	printf("%d\n", strlen(a));//255
//	//strlen 遇到‘\0’就会停下来
//	return 0;
//}


//unsigned char i = 0; //0-255
//int main()
//{
//	//会在0-255之间一直循环，变成死循环
//	for (i = 0;i <= 255; i++)
//	{
//		printf("hello world!\n");
//	}
//	return 0;
//}

/*结论：无符号数容易导致死循环，使用时要注意范围！*/

//浮点型的存储
//9.0
//1001.0
//(-1)^0 * 1.001 * 2^3
//(-1)^s  *  M   * 2^E
//s = 0
//M = 1.001  ――写的时候小数点左边的1省略
//E = 3   + 127（8bit的中间数）

//0.5(10) 
//0.1(2)
//1.0 * 2^(-1)
//s = 0
//M = 1.0
//E = -1


int main()
{
	int n = 9;
	//00000000 00000000 00000000 00001001 - 补码
	float* pFloat = (float*)&n;
	printf("n = %d\n", n);
	printf("*pFloat = %f\n", *pFloat);//E全0，所以打印0
	//(-1)^0 * 0.0000000 00000000 00001001 * 2^(-126)

	*pFloat = 9.0;
	//01000001000100000000000000000000
	//0 10000010 00100000000000000000000
	//0100 0001 0001 0000 0000 0000 0000 0000
	//41 10 00 00 
	printf("n = %d\n", n);//1,091,567,616
	printf("*pFloat = %f\n", *pFloat);

	return 0;
}

//int main()
//{
//	float f = 5.5;
//
//	/* 5.5 
//	101.1
//	(-1)^0 * 1.011 * 2^2
//	*/
//
//	//s = 0  M = 1.011  E = 2 (1 + 8 + 23)
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//40 B0 00 00 
//	return 0;
//}

//取出的三种情况
//Ⅰ E不为全0或者全1  ――正常情况
//Ⅱ E全0    E真实 = 1 - 127   +- 1.xxx * 2 ^(-127)――正负无限接近于0 ――处理M写作M = 0.xxx ，不写作 1.xxx
//Ⅲ E全1    E真实 = 255 - 127   表示正负无穷大
